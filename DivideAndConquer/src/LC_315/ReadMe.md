### 解题思路：
求在自己后面比自己小的数的个数，容易想到分治的想法，即把整个大问题二分成两个小问题，不断地将问题二分，求得答案后再merge。
> [X X X X Y Y Y Y]  
> [X X X X] [Y Y Y Y]  
> _i_____j _a____b  

如上例子，在大区间[i, b]中求解在自己后面比自己小的数的个数，将大区间[i, b]分为两个小区间[i, j]和[a, b]分别求解这个问题，
通过观察可以发现，在[a, b]区间中所有的问题都已经得到解决，但在[i, j]区间中得到的结果例如：res[i]还需要再加上[a, b]区间中
比nums[i]小的数的个数，为了快速计算出这个数量，很自然想到如果[a, b]区间有序，那么可以用binary search找nums[i]的ceiling。
res[i] += [a, b]区间中的结果。在返回上一层时，顺便将[i, b]区间进行排序，方便上一层的计算。v1使用了自带排序，v2用了
merge sort。